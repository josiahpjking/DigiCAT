#       arrange(., pairID) %>%
#       ungroup()
#
#      nbp_outcome <- lm(outcome_values ~ treatment_exposure + matching_values, data = newdata_paired2)
#
})
#
#  pooled_nbp <- summary(mice::pool(xyz))
}
nbp_mi_quick(handled_missingness = handled_missingness, treatment_variable = "gear", matching_variable = c("disp", "qsec"))
nbp_mi_quick <- function(handled_missingness, treatment_variable, outcome_variable,
matching_variable,...){
#comp <- complete(handled_missingness, "all", include = FALSE)
xyz <- with(handled_missingness, {
# f = paste0(treatment_variable,"~",paste0(matching_variable, collapse="+"))
#
# polr_res <- MASS::polr(as.formula(f), Hess = T)
#
# treatment_values <- get(treatment_variable)
# treatment_values <- as.numeric(as.character(treatment_values))
matching_values <- list()
for(matching_variable_name in matching_variable){
tmp <- get(matching_variable_name)
matching_values <- append(matching_values, tmp)
}
#     outcome_values <- get(outcome_variable)
#
#   dat_cols <- data.frame(treatment_values,
#                             matching_values,
#                             outcome_values)
#
#   pollyps <- as.data.frame(cbind(
#      dat_cols,
#     polr_res$model,polr_res$lp))
#
#   pollyps$ID <- seq_along(pollyps[,1])
#   pollyps$ID <- as.character(pollyps$ID)
#
#      #create distance matrix:
#
#      eps<-1*10^-100 #specify epsilon to be very small positive number
#      result <- matrix(ncol = nrow(pollyps), nrow = nrow(pollyps))
#
# matj <- matrix(data = treatment_values, nrow = nrow(pollyps), ncol = nrow(pollyps), byrow = F)
#                       matk <- matrix(data = treatment_values, nrow = nrow(pollyps), ncol = nrow(pollyps), byrow = T)
#
#                      res <- matj - matk
#                      res_squared <- res^2
#
#                      lpj <- matrix(data = polr_res$lp, nrow = nrow(pollyps), ncol = nrow(pollyps), byrow = F)
#                      lpk <- matrix(data = polr_res$lp, nrow = nrow(pollyps), ncol = nrow(pollyps), byrow = T)
#
#                      lp_res <- lpj - lpk
#                      lp_res_abs <- abs(lp_res)
#                      lp_calc <- 0.15 * sqrt(var(polr_res$lp))
#                      lp_logical <- lp_res_abs <= lp_calc
#
#                      lp_res_squared_plus_eps <- (lp_res^2) + eps
#
#                      res_squared[!lp_logical] <- 10^11
#                      res_squared[lp_logical] <- 10^11 * (lp_res_squared_plus_eps[lp_logical]) / res_squared[lp_logical]
#
#                      result <- res_squared
#
#                      row.names(result)<-pollyps$ID
#
#                      dist1<-nbpMatching::distancematrix(result)
#
#                      nbpmatches<-nbpMatching::nonbimatch(dist1,
#                                                          threshold=999999,
#                                                          precision = 7)
#
#                      nbpmatches_matched<-nbpmatches$halves[nbpmatches$halves$Distance!=999999, ] # eliminate unmatched
#
#                      nbpmatches_matched$pairID<-paste("p", 1:length(nbpmatches_matched$Group1.ID), sep="") #add in 'pair ID' var
#                      nbpmatches_matched<-tibble(nbpmatches_matched) #tibble so that tidyverse can be leveraged
#                      nbpmatches_matched_long<- tidyr::pivot_longer(nbpmatches_matched,                   # long format
#                                                                    cols = c(Group1.ID, Group2.ID),
#                                                                    names_to = "group",
#                                                                    values_to = "ID")
#
#                     dat_cols <- data.frame(pollyps) # recreate dataframe
#
#                     newdata_paired <- left_join(dat_cols, nbpmatches_matched_long, by = "ID")
#
#                     newdata_paired2 <- newdata_paired %>%
#                        mutate(treatment_values = as.numeric(treatment_values)) %>%
#       group_by(pairID) %>%  #pairID is the ID for each pair
#       mutate(first = max(treatment_values) , #create dose variable
#              treatment_exposure = factor(ifelse(treatment_values == first, "high", "low"))) %>%
#       #select(-c(group, treatment_variable)) %>%
#       arrange(., pairID) %>%
#       ungroup()
#
#      nbp_outcome <- lm(outcome_values ~ treatment_exposure + matching_values, data = newdata_paired2)
#
})
#
#  pooled_nbp <- summary(mice::pool(xyz))
}
nbp_mi_quick(handled_missingness = handled_missingness, treatment_variable = "gear", matching_variable = c("disp", "qsec"))
nbp_mi_quick <- function(handled_missingness, treatment_variable, outcome_variable,
matching_variable,...){
#comp <- complete(handled_missingness, "all", include = FALSE)
xyz <- with(handled_missingness, {
# f = paste0(treatment_variable,"~",paste0(matching_variable, collapse="+"))
#
# polr_res <- MASS::polr(as.formula(f), Hess = T)
#
# treatment_values <- get(treatment_variable)
# treatment_values <- as.numeric(as.character(treatment_values))
# matching_values <- list()
# for(matching_variable_name in matching_variable){
#   tmp <- get(matching_variable_name)
#   matching_values <- append(matching_values, tmp)
# }
#     outcome_values <- get(outcome_variable)
#
#   dat_cols <- data.frame(treatment_values,
#                             matching_values,
#                             outcome_values)
#
#   pollyps <- as.data.frame(cbind(
#      dat_cols,
#     polr_res$model,polr_res$lp))
#
#   pollyps$ID <- seq_along(pollyps[,1])
#   pollyps$ID <- as.character(pollyps$ID)
#
#      #create distance matrix:
#
#      eps<-1*10^-100 #specify epsilon to be very small positive number
#      result <- matrix(ncol = nrow(pollyps), nrow = nrow(pollyps))
#
# matj <- matrix(data = treatment_values, nrow = nrow(pollyps), ncol = nrow(pollyps), byrow = F)
#                       matk <- matrix(data = treatment_values, nrow = nrow(pollyps), ncol = nrow(pollyps), byrow = T)
#
#                      res <- matj - matk
#                      res_squared <- res^2
#
#                      lpj <- matrix(data = polr_res$lp, nrow = nrow(pollyps), ncol = nrow(pollyps), byrow = F)
#                      lpk <- matrix(data = polr_res$lp, nrow = nrow(pollyps), ncol = nrow(pollyps), byrow = T)
#
#                      lp_res <- lpj - lpk
#                      lp_res_abs <- abs(lp_res)
#                      lp_calc <- 0.15 * sqrt(var(polr_res$lp))
#                      lp_logical <- lp_res_abs <= lp_calc
#
#                      lp_res_squared_plus_eps <- (lp_res^2) + eps
#
#                      res_squared[!lp_logical] <- 10^11
#                      res_squared[lp_logical] <- 10^11 * (lp_res_squared_plus_eps[lp_logical]) / res_squared[lp_logical]
#
#                      result <- res_squared
#
#                      row.names(result)<-pollyps$ID
#
#                      dist1<-nbpMatching::distancematrix(result)
#
#                      nbpmatches<-nbpMatching::nonbimatch(dist1,
#                                                          threshold=999999,
#                                                          precision = 7)
#
#                      nbpmatches_matched<-nbpmatches$halves[nbpmatches$halves$Distance!=999999, ] # eliminate unmatched
#
#                      nbpmatches_matched$pairID<-paste("p", 1:length(nbpmatches_matched$Group1.ID), sep="") #add in 'pair ID' var
#                      nbpmatches_matched<-tibble(nbpmatches_matched) #tibble so that tidyverse can be leveraged
#                      nbpmatches_matched_long<- tidyr::pivot_longer(nbpmatches_matched,                   # long format
#                                                                    cols = c(Group1.ID, Group2.ID),
#                                                                    names_to = "group",
#                                                                    values_to = "ID")
#
#                     dat_cols <- data.frame(pollyps) # recreate dataframe
#
#                     newdata_paired <- left_join(dat_cols, nbpmatches_matched_long, by = "ID")
#
#                     newdata_paired2 <- newdata_paired %>%
#                        mutate(treatment_values = as.numeric(treatment_values)) %>%
#       group_by(pairID) %>%  #pairID is the ID for each pair
#       mutate(first = max(treatment_values) , #create dose variable
#              treatment_exposure = factor(ifelse(treatment_values == first, "high", "low"))) %>%
#       #select(-c(group, treatment_variable)) %>%
#       arrange(., pairID) %>%
#       ungroup()
#
#      nbp_outcome <- lm(outcome_values ~ treatment_exposure + matching_values, data = newdata_paired2)
#
})
#
#  pooled_nbp <- summary(mice::pool(xyz))
}
nbp_mi_quick(handled_missingness = handled_missingness, treatment_variable = "gear", matching_variable = c("disp", "qsec"))
nbp_mi_quick <- function(handled_missingness, treatment_variable, outcome_variable,
matching_variable,...){
#comp <- complete(handled_missingness, "all", include = FALSE)
xyz <- with(handled_missingness, {
# f = paste0(treatment_variable,"~",paste0(matching_variable, collapse="+"))
#
# polr_res <- MASS::polr(as.formula(f), Hess = T)
#
# treatment_values <- get(treatment_variable)
# treatment_values <- as.numeric(as.character(treatment_values))
# matching_values <- list()
# for(matching_variable_name in matching_variable){
#   tmp <- get(matching_variable_name)
#   matching_values <- append(matching_values, tmp)
}
#     outcome_values <- get(outcome_variable)
#
#   dat_cols <- data.frame(treatment_values,
#                             matching_values,
#                             outcome_values)
#
#   pollyps <- as.data.frame(cbind(
#      dat_cols,
#     polr_res$model,polr_res$lp))
#
#   pollyps$ID <- seq_along(pollyps[,1])
#   pollyps$ID <- as.character(pollyps$ID)
#
#      #create distance matrix:
#
#      eps<-1*10^-100 #specify epsilon to be very small positive number
#      result <- matrix(ncol = nrow(pollyps), nrow = nrow(pollyps))
#
# matj <- matrix(data = treatment_values, nrow = nrow(pollyps), ncol = nrow(pollyps), byrow = F)
#                       matk <- matrix(data = treatment_values, nrow = nrow(pollyps), ncol = nrow(pollyps), byrow = T)
#
#                      res <- matj - matk
#                      res_squared <- res^2
#
#                      lpj <- matrix(data = polr_res$lp, nrow = nrow(pollyps), ncol = nrow(pollyps), byrow = F)
#                      lpk <- matrix(data = polr_res$lp, nrow = nrow(pollyps), ncol = nrow(pollyps), byrow = T)
#
#                      lp_res <- lpj - lpk
#                      lp_res_abs <- abs(lp_res)
#                      lp_calc <- 0.15 * sqrt(var(polr_res$lp))
#                      lp_logical <- lp_res_abs <= lp_calc
#
#                      lp_res_squared_plus_eps <- (lp_res^2) + eps
#
#                      res_squared[!lp_logical] <- 10^11
#                      res_squared[lp_logical] <- 10^11 * (lp_res_squared_plus_eps[lp_logical]) / res_squared[lp_logical]
#
#                      result <- res_squared
#
#                      row.names(result)<-pollyps$ID
#
#                      dist1<-nbpMatching::distancematrix(result)
#
#                      nbpmatches<-nbpMatching::nonbimatch(dist1,
#                                                          threshold=999999,
#                                                          precision = 7)
#
#                      nbpmatches_matched<-nbpmatches$halves[nbpmatches$halves$Distance!=999999, ] # eliminate unmatched
#
#                      nbpmatches_matched$pairID<-paste("p", 1:length(nbpmatches_matched$Group1.ID), sep="") #add in 'pair ID' var
#                      nbpmatches_matched<-tibble(nbpmatches_matched) #tibble so that tidyverse can be leveraged
#                      nbpmatches_matched_long<- tidyr::pivot_longer(nbpmatches_matched,                   # long format
#                                                                    cols = c(Group1.ID, Group2.ID),
#                                                                    names_to = "group",
#                                                                    values_to = "ID")
#
#                     dat_cols <- data.frame(pollyps) # recreate dataframe
#
#                     newdata_paired <- left_join(dat_cols, nbpmatches_matched_long, by = "ID")
#
#                     newdata_paired2 <- newdata_paired %>%
#                        mutate(treatment_values = as.numeric(treatment_values)) %>%
#       group_by(pairID) %>%  #pairID is the ID for each pair
#       mutate(first = max(treatment_values) , #create dose variable
#              treatment_exposure = factor(ifelse(treatment_values == first, "high", "low"))) %>%
#       #select(-c(group, treatment_variable)) %>%
#       arrange(., pairID) %>%
#       ungroup()
#
#      nbp_outcome <- lm(outcome_values ~ treatment_exposure + matching_values, data = newdata_paired2)
#
#})
#
#  pooled_nbp <- summary(mice::pool(xyz))
}
nbp_mi_quick <- function(handled_missingness, treatment_variable, outcome_variable,
matching_variable,...){
#comp <- complete(handled_missingness, "all", include = FALSE)
xyz <- with(handled_missingness, {
# f = paste0(treatment_variable,"~",paste0(matching_variable, collapse="+"))
#
# polr_res <- MASS::polr(as.formula(f), Hess = T)
#
# treatment_values <- get(treatment_variable)
# treatment_values <- as.numeric(as.character(treatment_values))
# matching_values <- list()
# for(matching_variable_name in matching_variable){
#   tmp <- get(matching_variable_name)
#   matching_values <- append(matching_values, tmp)
})}
nbp_mi_quick(handled_missingness = handled_missingness, treatment_variable = "gear", matching_variable = c("disp", "qsec"))
nbp_mi_quick(handled_missingness = handled_missingness, treatment_variable = "gear", matching_variable = c("disp", "qsec"), outcome_variable = "mpg")
data(mtcars)
data(mtcars)
mtcars$gear <- as.factor(mtcars$gear)
handled_missingness <- mice::mice(mtcars)
data(mtcars)
mtcars$gear <- as.factor(mtcars$gear)
handled_missingness <- mice::mice(mtcars)
mtcars$gear <- as.factor(mtcars$gear)
handled_missingness <- mice::mice(mtcars)
nbp_mi_quick <- function(handled_missingness, treatment_variable, outcome_variable,
matching_variable,...){
#comp <- complete(handled_missingness, "all", include = FALSE)
xyz <- with(handled_missingness, {
# f = paste0(treatment_variable,"~",paste0(matching_variable, collapse="+"))
#
# polr_res <- MASS::polr(as.formula(f), Hess = T)
#
# treatment_values <- get(treatment_variable)
# treatment_values <- as.numeric(as.character(treatment_values))
# matching_values <- list()
# for(matching_variable_name in matching_variable){
#   tmp <- get(matching_variable_name)
#   matching_values <- append(matching_values, tmp)
})}
nbp_mi_quick(handled_missingness = handled_missingness, treatment_variable = "gear", outcome_variable = "mpg", matching_variable = c("disp", "qsec"))
nbp_mi_quick <- function(handled_missingness, treatment_variable, outcome_variable,
matching_variable,...){
#comp <- complete(handled_missingness, "all", include = FALSE)
xyz <- with(handled_missingness, {
# f = paste0(treatment_variable,"~",paste0(matching_variable, collapse="+"))
#
# polr_res <- MASS::polr(as.formula(f), Hess = T)
#
# treatment_values <- get(treatment_variable)
# treatment_values <- as.numeric(as.character(treatment_values))
matching_values <- list()
for(matching_variable_name in matching_variable){
tmp <- get(matching_variable_name)
matching_values <- append(matching_values, tmp)
}})}
mtcars$gear <- as.factor(mtcars$gear)
handled_missingness <- mice::mice(mtcars)
gc()
gc()
data(mtcars)
mtcars$gear <- as.factor(mtcars$gear)
handled_missingness <- mice::mice(mtcars)
handled_missingness <- mice::mice(mtcars)
nbp_mi_quick <- function(handled_missingness, treatment_variable, outcome_variable,
matching_variable,...){
#comp <- complete(handled_missingness, "all", include = FALSE)
xyz <- with(handled_missingness, {
# f = paste0(treatment_variable,"~",paste0(matching_variable, collapse="+"))
#
# polr_res <- MASS::polr(as.formula(f), Hess = T)
#
# treatment_values <- get(treatment_variable)
# treatment_values <- as.numeric(as.character(treatment_values))
matching_values <- list()
for(matching_variable_name in matching_variable){
tmp <- get(matching_variable_name)
matching_values <- append(matching_values, tmp)
}})}
handled_missingness <- mice::mice(mtcars)
data(mtcars)
mtcars$gear <- as.factor(mtcars$gear)
handled_missingness <- mice::mice(mtcars)
handled_missingness <- mice::mice(mtcars, method = "rf")
handled_missingness <- mice::mice(mtcars, method = "pmm")
gc()
#### NBP testing ####
# random data - ignore
data(mtcars)
handled <- mice(mtcars)
handled <- mice::mice(mtcars)
handled <- mice::mice(mtcars)
handled <- mice::mice(mtcars)
#### NBP testing ####
# random data - ignore
data(mtcars)
handled <- mice::mice(mtcars)
handled <- mice::mice(mtcars)
N =500
A = matrix(runif(5^2)*2-1, ncol = 5)
Xmat = MASS::mvrnorm(N, mu=rnorm(5,0,3), Sigma = t(A)%*%A)
lp = apply(Xmat, 2, scale)%*%rnorm(5,0,2)
t = rbinom(N,1,plogis(lp))
y = base::cbind(Xmat,t) %*% c(rnorm(5,0,1),2) + rnorm(N,0,1)
df <- as.data.frame(base::cbind(Xmat, t, y))
names(df) <- c(letters[1:5], "t", "y")
source("R/propensity_estimation_stage.R")
setwd("C:/Users/hwright2/Documents/digicat")
source("R/propensity_estimation_stage.R")
abc <- estimation_stage(.data = df2$amp, missing_method = "complete", model_type = "glm",
treatment_variable = "t", matching_variable = c("a", "b"))
abc <- estimation_stage(.data = df, missing_method = "complete", model_type = "glm",
treatment_variable = "t", matching_variable = c("a", "b"))
source("R/balance_data.R")
source("R/outcome_analysis_stage.R")
source("R/balance_data.R")
ghi <- balance_data(counterfactual_method = "psm", treatment_variable = "t",
matching_variable = c("a", "b"), PS_estimation_object = abc,
missing_method = "complete")
mno <- outcome_analysis_stage(balanced_data = ghi, counterfactual_method = "psm",
outcome_variable = "y",
treatment_variable = "t",
matching_variable = c("a", "b"),
psmodel_obj = abc,
missing_method = "complete")
source("R/outcome_analysis_stage.R")
mno <- outcome_analysis_stage(balanced_data = ghi, counterfactual_method = "iptw",
outcome_variable = "y",
treatment_variable = "t",
matching_variable = c("a", "b"),
psmodel_obj = abc,
missing_method = "mi")
source("R/outcome_analysis_stage.R")
mno <- outcome_analysis_stage(balanced_data = ghi, counterfactual_method = "iptw",
outcome_variable = "y",
treatment_variable = "t",
matching_variable = c("a", "b"),
psmodel_obj = abc,
missing_method = "mi")
mno <- outcome_analysis_stage(balanced_data = ghi, counterfactual_method = "psm",
outcome_variable = "y",
treatment_variable = "t",
matching_variable = c("a", "b"),
psmodel_obj = abc,
missing_method = "complete")
View(mno)
mno <- outcome_analysis_stage(balanced_data = ghi, counterfactual_method = "psm",
outcome_variable = "y",
treatment_variable = "t",
matching_variable = c("a", "b"),
psmodel_obj = abc,
missing_method = "complete")
View(mno)
ghi <- balance_data(counterfactual_method = "iptw", treatment_variable = "t",
matching_variable = c("a", "b"), PS_estimation_object = abc,
missing_method = "complete")
mno <- outcome_analysis_stage(balanced_data = ghi, counterfactual_method = "iptw",
outcome_variable = "y",
treatment_variable = "t",
matching_variable = c("a", "b"),
psmodel_obj = abc,
missing_method = "complete")
View(mno)
data(nhanes)
# nb: model/variable choice makes no sense due to variable types
# but used as an example to add cluster/strata/weights etc
abc <- estimation_stage(.data = nhanes, missing_method = "weighting", model_type = "glm",
treatment_variable = "HI_CHOL", matching_variable = "race",
weighting_variable = "WTMEC2YR", cluster_variable = "SDMVPSU",
strata_variable = "SDMVSTRA")
library(survey)
# nb: model/variable choice makes no sense due to variable types
# but used as an example to add cluster/strata/weights etc
abc <- estimation_stage(.data = nhanes, missing_method = "weighting", model_type = "glm",
treatment_variable = "HI_CHOL", matching_variable = "race",
weighting_variable = "WTMEC2YR", cluster_variable = "SDMVPSU",
strata_variable = "SDMVSTRA")
# nb: model/variable choice makes no sense due to variable types
# but used as an example to add cluster/strata/weights etc
data(fpc)
abc <- estimation_stage(.data = fpc, missing_method = "weighting", model_type = "glm",
treatment_variable = "nh", matching_variable = "x",
weighting_variable = "weight", cluster_variable = "psuid", # check variations of design vars allowed
strata_variable = "stratid")
ghi <- balance_data(counterfactual_method = "iptw", treatment_variable = "nh",
matching_variable = "x", PS_estimation_object = abc,
missing_method = "weighting")
## TO DO - edit design object in extract_balanced_data
mno <- outcome_analysis_stage(balanced_data = ghi, counterfactual_method = "iptw",
outcome_variable = "Nh",
treatment_variable = "nh",
matching_variable = "x",
psmodel_obj = abc,
missing_method = "weighting",
weighting_variable = "weight")
mno
?comparisons
N =500
A = matrix(runif(5^2)*2-1, ncol = 5)
Xmat = MASS::mvrnorm(N, mu=rnorm(5,0,3), Sigma = t(A)%*%A)
lp = apply(Xmat, 2, scale)%*%rnorm(5,0,2)
t = rbinom(N,1,plogis(lp))
y = base::cbind(Xmat,t) %*% c(rnorm(5,0,1),2) + rnorm(N,0,1)
df <- as.data.frame(base::cbind(Xmat, t, y))
names(df) <- c(letters[1:5], "t", "y")
df2 = mice::ampute(df,
prop = 0.05)
abc <- estimation_stage(.data = df2$amp, missing_method = "complete", model_type = "glm",
treatment_variable = "t", matching_variable = c("a", "b"))
ghi <- balance_data(counterfactual_method = "iptw", treatment_variable = "t",
matching_variable = c("a", "b"), PS_estimation_object = abc,
missing_method = "complete")
mno <- outcome_analysis_stage(balanced_data = ghi, counterfactual_method = "iptw",
outcome_variable = "y",
treatment_variable = "t",
matching_variable = c("a", "b"),
psmodel_obj = abc,
missing_method = "complete")
mno
ghi <- balance_data(counterfactual_method = "psm", treatment_variable = "t",
matching_variable = c("a", "b"), PS_estimation_object = abc,
missing_method = "complete")
mno <- outcome_analysis_stage(balanced_data = ghi, counterfactual_method = "psm",
outcome_variable = "y",
treatment_variable = "t",
matching_variable = c("a", "b"),
psmodel_obj = abc,
missing_method = "complete")
mno
